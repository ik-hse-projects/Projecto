using System.Collections.Generic;

namespace Projecto
{
    /// <summary>
    /// Означает, что задача может содержать подзадачи.
    /// </summary>
    public interface IHaveSubtasks
    {
        /// <summary>
        /// Список подзадач. Можно менять.
        ///
        /// Убедительная просьба помещать сбюда только разерешённые задачи (<see cref="AllowedSubtasks"/>).
        /// </summary>
        public List<ITask> Subtasks { get; }
        
        // Небольшое отступление: я какое-то время пытался потребовать (а не убедительно просить),
        // чтобы в Subtasksмогли быть только разрешённые задачи.
        // В целом это реализуется через создание интерфейса `ISubtaskOf<TParentTask>`
        // и замены текущего простого списка Subtasks на `List<ISubtaskOf<TSelf>> Subtasks`.
        // Но это влечёт за собой некоторые последствия:
        // - Теперь `IHaveSubtasks` имеет тип-аргумент (`TSelf`). Следовательно его нельзя просто так помещать в списки.
        // - Меняется сторона, устанавливающая правила:
        //   на данный момент родительская задача указывает кто может быть подзадачей, и это логично.
        //   А с введением интерфейса получется наоборот: подзадача указывает, что она является может быть подзадачей
        //   какой-то другой. Причём эта другая "надзадача" может об этом даже не догадываться
        // - ITaskKind.Create должен возвращать ISubtaskOf<???>, где ??? – соответствющий задаче тип.
        //   Следовательно ITaskKind тоже получает аргумент-тип, а значит его нельзя поместить а список.
        //   Но на тот момент было чуть-чуть по-другому и там вовсе не было (ещё) ITaskKind.
        // - Из-за отсутствия ITaskKind[] AllowedSubtasks нельзя взять и получить список всех подзадач для данной.
        //   Но хорошо, у нас ведь есть список всех задач вообще; вот они: Task, Epic, Story, ...
        //   Можно прст перебрать их все и проверить, какие из них реализуют ISubtaskOf<Parent>
        //   Хочется написать функцию вроде такой: AddSubtaskTo(ITask parent).
        //   Внимание, вопрос! Какой тип здесь имеет parent? Ответ: Непонятно!
        //   (где-то здесь я гуглил проверять, реализуется ли типом интерфейс через *рефликсию*, но отбросил это мысль)
        //   Получается, что функция тоже должна иметь тип-аргумент: AddSubtaskTo<TParent>(TParent parent)
        //   Однако мы ведь хотим хранить все задачи проекта в одном спиcке, а значит где-то эти точные типы исчезают
        //   и появляются интерфейсы. А значит мы не можем их передавать в AddSubtaskTo просто так.
        //   В целом, это можно было бы решить, добавив ещё один switch по всем известным типам задач, но это уже
        //   второй раз, когда требуется перебирать все типы задач. А что, если мы добавим ещё один вид?
        //   Добавлять везде прверку не хочется: можно легко забыть и получить исключение.
        // Именно поэтому я выбрал меньшее зло и не стал здесь жёстко требовать, чтобы Subtasks содержал только
        // подзадачи правильных видов.

        /// <summary>
        /// Список допустимых подзадач.
        /// </summary>
        public IReadOnlyList<ITaskKind> AllowedSubtasks { get; }
    }
}